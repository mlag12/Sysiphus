<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sísifo na Montanha — Versão Completa</title>
  <style>
    :root {
      --btn-bg: linear-gradient(135deg, #ff004d, #ffb347);
      --btn-border: #000;
      --accent: #ff004d;
      --neon: #00ffff;
    }

    /* reset mínimo */
    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #000;
      color: #fff;
      font-family: "Courier New", monospace;
      overflow: hidden;
      /* Evita barras de rolagem */
    }

    /* canvas full screen */
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #000;
    }

    /* UI overlay */
    #ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    #placar {
      position: absolute;
      top: 2%;
      left: 2%;
      color: #fff;
      font-weight: 800;
      font-size: 3vh;
      text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
      z-index: 110;
      white-space: nowrap;
    }

    /* --- Joystick Estilizado (Adaptado para Mobile) --- */
    #joystick-container {
      position: fixed;
      bottom: 5%; /* Ajustado para ficar mais acessível */
      left: 50%;
      transform: translateX(-50%);
      z-index: 120;
      pointer-events: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px; /* Bordas mais arredondadas */
      padding: 10px; /* Padding menor */
      border: 2px dashed var(--neon); /* Borda mais fina */
      width: 180px; /* Largura menor para o container */
      height: 70px; /* Altura menor para o container */
    }

    #joystick-base {
      width: 100%;
      height: 15px; /* Altura da "trilha" reduzida */
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      position: relative;
      display: flex;
      align-items: center;
      cursor: grab;
    }

    #joystick-thumb {
      width: 45px; /* Largura do "pauzinho" reduzida */
      height: 45px; /* Altura do "pauzinho" reduzida */
      background: var(--btn-bg);
      border: 3px solid var(--btn-border); /* Borda mais fina */
      border-radius: 50%;
      position: absolute;
      cursor: grab;
      transition: none; /* Remove transição para controle mais responsivo */
      box-shadow: 0 0 10px rgba(255, 0, 77, 0.7);
      transform: translateX(-50%); /* Ajuste para o centro do thumb */
      left: 50%; /* Posição inicial central */
    }

    /* --- Fim do Joystick Estilizado --- */


    #menu-container {
      position: fixed;
      top: 2%;
      right: 2%;
      z-index: 130;
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }

    #botao-menu {
      cursor: pointer;
      font-size: 14px; /* Fonte menor */
      background: var(--btn-bg);
      border: 2px solid #000;
      padding: 5px 10px; /* Padding menor */
      border-radius: 8px;
    }

    #menu-itens {
      display: none;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      margin-top: 4px;
    }

    #menu-container.open #menu-itens {
      display: flex;
    }

    #menu-itens button,
    #menu-itens label {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      cursor: pointer;
      font-size: 13px; /* Fonte menor */
      background: var(--btn-bg);
      border: 2px solid #000;
      padding: 6px 10px; /* Padding menor */
      border-radius: 8px;
      white-space: nowrap;
    }

    #menu-itens label input {
      margin-left: 0;
      transform: scale(1.1);
    }

    /* ranking modal */
    #ranking-absurdo {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(2deg);
      padding: 4vh 6vw; /* Padding um pouco menor */
      background: rgba(0, 0, 0, 0.95);
      border: 3px dashed red; /* Borda mais fina */
      color: white;
      font-family: "Courier New", monospace;
      font-size: 3vh; /* Tamanho de fonte menor */
      text-align: center;
      z-index: 1000;
      max-height: 65vh; /* Altura máxima menor */
      overflow-y: auto;
      min-width: 350px; /* Largura mínima menor */
      width: auto;
      white-space: nowrap;
    }


    #ranking-absurdo h1 {
      font-family: Impact, fantasy;
      font-size: 5vh; /* Tamanho de fonte menor */
      color: var(--accent);
      text-shadow: 2px 2px 6px rgba(255, 0, 77, 0.5);
      margin-bottom: 1.5vh;
      border-bottom: 2px dashed yellow;
      padding-bottom: 0.8vh;
    }

    #ranking-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #ranking-list li {
      margin-bottom: 1vh; /* Margem menor */
      color: var(--neon);
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0, 255, 255, 0.4);
    }

    /* name input box */
    .caixa-nome {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-5deg);
      padding: 4vh 6vw; /* Padding menor */
      background: linear-gradient(45deg, #ff00ff, #00ffff);
      border: 3px dashed yellow; /* Borda mais fina */
      color: white;
      font-family: "Courier New", monospace;
      font-size: 3.5vh; /* Tamanho de fonte menor */
      text-align: center;
      z-index: 999;
    }

    .caixa-nome p {
      line-height: 1.4; /* Espaçamento menor */
    }

    .caixa-nome input {
      font-size: 2.5vh; /* Tamanho de fonte menor */
      padding: 10px; /* Padding menor */
      width: 100%;
      border-radius: 8px;
      border: 2px solid #000;
      margin-top: 8px; /* Margem menor */
    }

    .caixa-nome button {
      margin-top: 12px; /* Margem menor */
      font-size: 2.4vh; /* Tamanho de fonte menor */
      padding: 8px 15px; /* Padding menor */
      border-radius: 10px;
      cursor: pointer;
    }

    /* Oculta o botão antigo de empurrar */
    #botao-empurrar {
      display: none;
    }
  </style>
</head>

<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div id="placar">Montanhas: 0</div>

    <div id="joystick-container">
      <div id="joystick-base">
        <div id="joystick-thumb"></div>
      </div>
    </div>
    <div id="menu-container">
      <button id="botao-menu">Menu</button>
      <div id="menu-itens">
        <button id="botao-ranking">Ranking</button>
        <label><input type="checkbox" id="mostrar-score"> Mostrar Score</label>
      </div>
    </div>

    <div id="ranking-absurdo">
      <h1>TOP 10:</h1>
      <ul id="ranking-list"></ul>
    </div>
  </div>

  <script type="module">
    // --------------------------
    // Firebase v10 (Firestore)
    // --------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore,
      collection,
      addDoc,
      getDocs,
      query,
      orderBy,
      limit
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // === Firebase configuration - mantenha a sua informação aqui ===
    const firebaseConfig = {
      apiKey: "AIzaSyAk2SE580mZCNbLpAboxC7A4FlviilKtIE",
      authDomain: "sysiphus-afea7.firebaseapp.com",
      projectId: "sysiphus-afea7",
      storageBucket: "sysiphus-afea7.firebasestorage.app",
      messagingSenderId: "182996428651",
      appId: "1:182996428651:web:82675bca0f31c978db8e2e",
      measurementId: "G-G6N5MKSFV3"
    };

    // Inicializa o Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Referência para a coleção de scores
    const scoresCollection = collection(db, "scores");

    // --------------------------
    // Elementos DOM
    // --------------------------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const placarEl = document.getElementById('placar');

    // Joystick Elements
    const joystickContainer = document.getElementById('joystick-container');
    const joystickThumb = document.getElementById('joystick-thumb');
    const joystickBase = document.getElementById('joystick-base');

    const botaoMenu = document.getElementById('botao-menu');
    const menuContainer = document.getElementById('menu-container');
    const botaoRanking = document.getElementById('botao-ranking');
    const rankingBox = document.getElementById('ranking-absurdo');
    const rankingList = document.getElementById('ranking-list');
    const checkbox = document.getElementById('mostrar-score');

    // --------------------------
    // Imagens (coloque na pasta images)
    // --------------------------
    const IMG_BG = new Image(); IMG_BG.src = 'images/montanha.jpg';
    const IMG_SISIFO = new Image(); IMG_SISIFO.src = 'images/sisifo.png';
    const IMG_PEDRA = new Image(); IMG_PEDRA.src = 'images/pedra.png';

    // --------------------------
    // Estado do jogo
    // --------------------------
    const ESTADOS = { PARADO: 0, SUBINDO: 1, PAUSA: 2, QUEDA: 3, SUICIDIO: 4 };
    let estado = ESTADOS.PARADO;
    let montanhas = 0;
    let movimentoAtivo = false;
    let mostrarScore = false;

    // Variáveis para controle horizontal do personagem
    let movimentoHorizontal = 0; // Valor entre -1 e 1, representando a direção e intensidade do joystick
    let personagemOffsetX = 0; // Deslocamento horizontal do personagem em pixels
    const maxPersonagemOffsetX = 0.25 * canvas.width; // Desvio máximo horizontal (25% da tela) - Aumentado um pouco
    const sensibilidadePersonagem = 0.007; // Ajusta a velocidade com que o personagem responde ao joystick

    checkbox.addEventListener('change', () => { mostrarScore = checkbox.checked; });
    botaoMenu.addEventListener('click', () => menuContainer.classList.toggle('open'));

    botaoRanking.addEventListener('click', () => {
      const isShown = rankingBox.style.display === 'block';
      rankingBox.style.display = isShown ? 'none' : 'block';
      if (!isShown) atualizarRanking();
    });

    // --------------------------
    // novas pedras caindo durante subida
    // --------------------------
    const pedrasCaindo = [];
    const PEDRA_CAI_W = 40; // largura padrão
    const PEDRA_CAI_H = 40; // altura padrão
    const freqQueda = 0.01; // chance de gerar pedra a cada frame (0-1)


    // --- resize canvas & curves ---
    const curvaSubidaPct = [{ x: 0.15, y: 0.65 }, { x: 0.25, y: 0.40 }, { x: 0.40, y: 0.40 }, { x: 0.60, y: 0.40 }];
    const curvaQuedaPct = [{ x: 0.70, y: 0.40 }, { x: 0.75, y: 0.55 }, { x: 0.90, y: 0.65 }, { x: 0.99, y: 0.75 }];
    let curvaSubidaBasePx, curvaQuedaPx; // Armazenar as curvas em pixels
    let curvaSubidaBasePct = JSON.parse(JSON.stringify(curvaSubidaPct)); // Cópia da curva base em percentual

    function pctToPx(curva) { return curva.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height })); }

    function resize() {
      canvas.width = window.innerWidth; canvas.height = window.innerHeight;
      curvaSubidaBasePx = pctToPx(curvaSubidaBasePct); // Converte a curva base para pixels
      curvaQuedaPx = pctToPx(curvaQuedaPct);
    }
    window.addEventListener('resize', resize); resize();

    // --- Joystick Logic ---
    let joystickThumbCenterX = 0; // Posição X relativa do centro do thumb dentro da base
    let isDragging = false;

    function updateJoystickPosition(clientX) {
      const rectBase = joystickBase.getBoundingClientRect();
      const thumbWidth = joystickThumb.offsetWidth;

      // Calcula a posição do mouse/toque relativa ao *centro da base* do joystick
      let deltaX = clientX - rectBase.left - rectBase.width / 2;

      // Limita o movimento do centro do thumb para que ele não saia da base
      const maxDeltaX = (rectBase.width - thumbWidth) / 2;
      deltaX = clamp(deltaX, -maxDeltaX, maxDeltaX);

      joystickThumbCenterX = deltaX; // Atualiza a posição X relativa do thumb

      // Aplica a posição ao thumb do joystick. O left: 50% já centraliza, então adicionamos deltaX.
      joystickThumb.style.left = `calc(50% + ${joystickThumbCenterX}px)`;

      // Normaliza o movimento horizontal para um valor entre -1 e 1
      const normalizedMovement = joystickThumbCenterX / maxDeltaX;

      // Determina o valor de movimentoHorizontal após aplicar a dead zone
      const deadZoneFactor = 0.15; // 15% de dead zone no joystick
      if (Math.abs(normalizedMovement) > deadZoneFactor) {
        movimentoHorizontal = Math.sign(normalizedMovement) *
                           ((Math.abs(normalizedMovement) - deadZoneFactor) / (1 - deadZoneFactor));
        movimentoAtivo = true;
      } else {
        movimentoHorizontal = 0; // Dentro da dead zone, o personagem para
        movimentoAtivo = false;
      }

      // Se o jogo está parado, e houve movimento do joystick, iniciar ciclo
      // O personagem só começa a subir se houver um comando claro (não na dead zone)
      if (estado === ESTADOS.PARADO && movimentoHorizontal !== 0) {
        iniciarCiclo();
      }
    }

    function onPointerDown(e) {
      e.preventDefault();
      isDragging = true;
      joystickThumb.style.cursor = 'grabbing';
      document.body.style.cursor = 'grabbing';
      updateJoystickPosition(e.clientX);
    }

    function onPointerMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      updateJoystickPosition(e.clientX);
    }

    function onPointerUp(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      joystickThumb.style.cursor = 'grab';
      document.body.style.cursor = 'default';

      // Retorna o joystick ao centro quando solto
      joystickThumb.style.left = '50%'; // Volta para a posição inicial via CSS
      joystickThumbCenterX = 0;
      movimentoHorizontal = 0; // Para o movimento horizontal
      movimentoAtivo = false;
    }

    // Event listeners para o joystick
    joystickContainer.addEventListener('pointerdown', onPointerDown);
    joystickBase.addEventListener('pointerdown', onPointerDown); // Permite arrastar da base também
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('pointerleave', onPointerUp);

    // --- Fim do Joystick Logic ---


    // --- physics ---
    function cubicBezierPoint(t, p0, p1, p2, p3) {
      const lerp = (a, b, t) => ({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });
      const a = lerp(p0, p1, t), b = lerp(p1, p2, t), c = lerp(p2, p3, t);
      const d = lerp(a, b, t), e = lerp(b, c, t);
      return lerp(d, e, t);
    }

    let progressoSubida = 0, velSubida = 0, progressoQueda = 0, velQueda = 0;
    let maxVelSubida = 0.01, aceleracaoSubida = 0.003, desaceleraSubida = 0.9;
    let aceleracaoQuedaInit = 0.008, gravidadeQueda = 0.0002, pausaFrames = 0;

    function iniciarCiclo() {
      estado = ESTADOS.SUBINDO;
      progressoSubida = 0;
      velSubida = 0.005; // Velocidade inicial ao começar
      progressoQueda = 0;
      velQueda = 0;
      personagemOffsetX = 0; // Reseta o offset ao iniciar um novo ciclo
    }

    function reiniciarParaParado() {
      montanhas++;
      estado = ESTADOS.PARADO;
      progressoSubida = progressoQueda = 0;
      velSubida = velQueda = 0;
      movimentoAtivo = false;
      movimentoHorizontal = 0; // Zera o movimento horizontal
      personagemOffsetX = 0; // Zera o offset horizontal
    }


    function gerarPedraCaindo(xPersonagem, yPersonagem, wPersonagem, hPersonagem) {
      let x, y = -PEDRA_CAI_H;
      const zonaExclusaoRaio = Math.max(wPersonagem, hPersonagem) * 2; // raio da zona de exclusão ao redor do personagem

      let tentativas = 0;
      do {
        x = Math.random() * (canvas.width - PEDRA_CAI_W); // posição aleatória no topo
        y = -PEDRA_CAI_H; // sempre acima do topo da tela
        tentativas++;
        if (tentativas > 100) break; // evita loop infinito caso zona cubra muito
      } while (
        Math.hypot(
          x + PEDRA_CAI_W / 2 - (xPersonagem + wPersonagem / 2),
          y + PEDRA_CAI_H / 2 - (yPersonagem + hPersonagem / 2)
        ) < zonaExclusaoRaio
      );

      const velocidade = 2 + Math.random() * 3;
      pedrasCaindo.push({ x, y, velocidade });
    }


    function atualizarPedrasCaindo(xPersonagem, yPersonagem, wPersonagem, hPersonagem) {
      for (let i = pedrasCaindo.length - 1; i >= 0; i--) {
        const ped = pedrasCaindo[i];

        // Atualiza posição da pedra
        ped.y += ped.velocidade;

        // Desenhar pedra
        if (IMG_PEDRA.complete) {
          ctx.drawImage(IMG_PEDRA, ped.x, ped.y, PEDRA_CAI_W, PEDRA_CAI_H);
        }

        // Checar colisão com o personagem
        if (
          ped.x < xPersonagem + wPersonagem &&
          ped.x + PEDRA_CAI_W > xPersonagem &&
          ped.y < yPersonagem + hPersonagem &&
          ped.y + PEDRA_CAI_H > yPersonagem
        ) {
          // Colisão detectada: remove pedra e reinicia jogo
          pedrasCaindo.splice(i, 1);

          // Fim de jogo: chama função existente
          fimDoJogoSuicidio();

          // Reseta score e progresso
          montanhas = 0;
          progressoSubida = progressoQueda = 0;
          velSubida = velQueda = 0;

          return; // sai da função para não processar mais pedras neste frame
        }

        // Remove pedra se saiu da tela
        if (ped.y > canvas.height) {
          pedrasCaindo.splice(i, 1);
        }
      }
    }



    // --------------------------
    // FIREBASE: salvar apenas se entra no top10
    // Observações importantes sobre esta função:
    // - usamos `limitToLast(10)` para trazer até 10 registros ordenados por `score`.
    // - convertendo `score` para Number para evitar problemas com strings.
    // - ao salvar, adicionamos `ts` (timestamp) e `idClient` para ajudar a depuração.
    // - validamos o `nome` (máx 20 caracteres) e o `score` (Number >=0).
    // --------------------------
    // --------------------------
    // Função para salvar score no Firestore se estiver no top 10
    // --------------------------
    async function salvarScoreSeTop10(nome, score) {
      try {
        const top10Query = query(scoresCollection, orderBy("score", "desc"), limit(10));
        const snapshot = await getDocs(top10Query);
        let top10 = [];
        snapshot.forEach(doc => {
          top10.push({ id: doc.id, ...doc.data() });
        });

        // Verifica se entrou no top 10
        const entrou = top10.length < 10 || score > top10[top10.length - 1].score;

        if (entrou) {
          // Salva o novo score
          await addDoc(scoresCollection, {
            name: nome || "Anônimo",
            score: Number(score),
            createdAt: new Date()
          });
        }

        return entrou;
      } catch (err) {
        console.error("Erro ao salvar score:", err);
        return false;
      }
    }

    // --------------------------
    // Atualiza ranking exibido (top 10) a partir do Firestore
    // --------------------------
    async function atualizarRanking() {
      try {
        const top10Query = query(scoresCollection, orderBy("score", "desc"), limit(10));
        const snapshot = await getDocs(top10Query);

        rankingList.innerHTML = '';
        const scores = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          scores.push({ nome: data.name || 'Anônimo', score: Number(data.score) || 0 });
        });

        if (scores.length === 0) {
          const li = document.createElement('li');
          li.textContent = 'Ainda não há scores.';
          rankingList.appendChild(li);
          return;
        }

        scores.forEach((s, i) => {
          const li = document.createElement('li');
          li.textContent = `${i + 1}. ${s.nome} - ${s.score}`;
          rankingList.appendChild(li);
        });
      } catch (err) {
        console.error("Erro ao atualizar ranking:", err);
      }
    }

    // --------------------------
    // fim do jogo suicídio: pede nome e tenta salvar
    // - esta função cria a caixa de input e controla estados do botão
    // - bloqueia o botão salvar durante a operação para evitar múltiplos pushes
    // --------------------------
    // Função de fim de jogo com input de nome
    async function fimDoJogoSuicidio() {
      const scoreAtual = montanhas;

      // Pausa o jogo
      estado = ESTADOS.PARADO;
      movimentoAtivo = false;
      movimentoHorizontal = 0; // Zera o movimento horizontal
      personagemOffsetX = 0; // Zera o offset horizontal

      // Cria a caixa de input
      const caixaNome = document.createElement('div');
      caixaNome.className = 'caixa-nome';
      caixaNome.innerHTML = `
        <p>Você atingiu <strong>${scoreAtual}</strong> montanhas!</p>
        <p>Insira seu nome para o ranking:</p>
        <input type="text" id="nome-jogador" placeholder="Seu nome..." />
        <div style="margin-top:16px">
            <button id="salvar-absurdo">Salvar</button>
            <button id="cancelar-absurdo" style="margin-left:10px;">Cancelar</button>
        </div>
      `;
      document.body.appendChild(caixaNome);

      // Botão Salvar
      document.getElementById('salvar-absurdo').addEventListener('click', async () => {
        const nome = document.getElementById('nome-jogador').value.trim() || 'Anônimo';
        const entrou = await salvarScoreSeTop10(nome, scoreAtual);

        if (entrou) {
          console.log('Parabéns — você entrou no TOP 10!');
        } else {
          console.log('Não entrou no TOP 10 — mas score será registrado.');
        }

        // Remove a caixa e reseta o jogo
        document.body.removeChild(caixaNome);
        montanhas = 0;
        progressoSubida = progressoQueda = 0;
        velSubida = velQueda = 0;
        placarEl.textContent = `Montanhas: ${montanhas}`;

        atualizarRanking();
      });

      // Botão Cancelar
      document.getElementById('cancelar-absurdo').addEventListener('click', () => {
        document.body.removeChild(caixaNome);

        // Reseta o jogo mesmo cancelando
        montanhas = 0;
        progressoSubida = progressoQueda = 0;
        velSubida = velQueda = 0;
        placarEl.textContent = `Montanhas: ${montanhas}`;

        atualizarRanking();
      });
    }



    // --------------------------
    // desenho de fundo otimizado
    // --------------------------
    function desenharFundo() {
      if (!IMG_BG.complete) return;

      // calcula a escala para caber toda a imagem na tela sem cortar (fit)
      const scaleX = canvas.width / IMG_BG.width;
      const scaleY = canvas.height / IMG_BG.height;
      const scale = Math.min(scaleX, scaleY); // fit: menor escala para caber tudo

      const w = IMG_BG.width * scale;
      const h = IMG_BG.height * scale;

      // centraliza a imagem
      const offsetX = (canvas.width - w) / 2;
      const offsetY = (canvas.height - h) / 2;

      ctx.drawImage(IMG_BG, offsetX, offsetY, w, h);
    }


    // --------------------------
    // loop principal e renderização detalhada
    // --------------------------
    function loop() {

      // lógica de estados
      if (estado === ESTADOS.SUBINDO) {
        // Movimento vertical (subida) é sempre para frente (aumenta progressoSubida)
        velSubida = 0.005 + Math.abs(movimentoHorizontal) * 0.005; // Acelera um pouco mais ao desviar
        velSubida = Math.min(velSubida, maxVelSubida);
        progressoSubida += velSubida;

        // Atualiza o deslocamento horizontal do personagem APENAS se houver comando ativo
        if (movimentoHorizontal !== 0) {
          personagemOffsetX += movimentoHorizontal * sensibilidadePersonagem * canvas.width;
          personagemOffsetX = clamp(personagemOffsetX, -maxPersonagemOffsetX, maxPersonagemOffsetX);
        } else {
          // Se não há comando, o personagem tende a retornar ao centro suavemente
          // O movimento para trás (esquerda) só acontece se arrastar para a esquerda explicitamente.
          // Para retornar ao centro:
          personagemOffsetX *= 0.95; // Suaviza o retorno ao centro
          if (Math.abs(personagemOffsetX) < 1) personagemOffsetX = 0; // Zera se estiver muito perto
        }


        if (progressoSubida >= 1) {
          progressoSubida = 1;
          estado = ESTADOS.PAUSA;
          pausaFrames = 15;
          progressoQueda = 0;
          velQueda = aceleracaoQuedaInit;
        }
      } else if (estado === ESTADOS.PAUSA) {
        pausaFrames--;
        if (pausaFrames <= 0) estado = ESTADOS.QUEDA;
      } else if (estado === ESTADOS.QUEDA) {
        velQueda += gravidadeQueda;
        progressoQueda += velQueda;
        if (progressoQueda >= 1) {
          reiniciarParaParado();
        }
      } else if (estado === ESTADOS.SUICIDIO) {
        velQueda += gravidadeQueda;
        progressoQueda += velQueda;
        if (progressoQueda >= 1) {
          estado = ESTADOS.PARADO;
          fimDoJogoSuicidio();
        }
      }

      // limpar
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      desenharFundo();

      // calcular posições via bezier
      const pSisBase = cubicBezierPoint(progressoSubida, ...curvaSubidaBasePx); // Ponto na curva original (para Y)
      const pQueda = cubicBezierPoint(progressoQueda, ...curvaQuedaPx);

      // dimensões relativas
      const sisW = canvas.width * 0.12;
      const sisH = sisW * (IMG_SISIFO.height / IMG_SISIFO.width || 1);
      const pedW = sisW * 0.7;
      const pedH = pedW;

      // --- Desenho do Sísifo com Desvio Horizontal ---
      if (estado === ESTADOS.SUICIDIO) {
        const q = pQueda;
        const sisDesvio = Math.sin(progressoQueda * Math.PI * 0.5) * (canvas.width * 0.04);
        const sx = q.x - sisW / 2 + sisDesvio; const sy = q.y - sisH / 2;
        if (IMG_SISIFO.complete) ctx.drawImage(IMG_SISIFO, sx, sy, sisW, sisH);

        const px = q.x - pedW / 2 + Math.cos(progressoQueda * Math.PI * 1.5) * (canvas.width * 0.035);
        const py = q.y - pedH / 2;
        ctx.save(); ctx.translate(px + pedW / 2, py + pedH / 2); ctx.rotate(progressoQueda * Math.PI * 1.5); if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, -pedW / 2, -pedH / 2, pedW, pedH); ctx.restore();

      } else {
        // subida/pause/queda regular
        // A posição X do Sísifo agora é a posição da curva base + o offset de desvio
        let sx = pSisBase.x - sisW / 2 + personagemOffsetX;
        const sy = pSisBase.y - sisH + (canvas.height * 0.01);

        // Garante que Sísifo não saia da tela
        sx = Math.max(0, Math.min(canvas.width - sisW, sx));

        if (IMG_SISIFO.complete) ctx.drawImage(IMG_SISIFO, sx, sy, sisW, sisH);

        if (estado === ESTADOS.SUBINDO || estado === ESTADOS.PAUSA) {
          const px = sx + sisW * 0.4;
          const py = sy - pedH * 0.7;
          if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, px, py, pedW, pedH);
        }

        if (estado === ESTADOS.SUBINDO) {
          // gerar pedras com baixa frequência
          if (Math.random() < freqQueda) {
            const pedX = sx + sisW * 0.4; // Posição X da pedra baseada na posição atual de Sísifo
            gerarPedraCaindo(pedX, sy, pedW, pedH);
          }

          const pedX = sx + sisW * 0.4; // Posição X da pedra baseada na posição atual de Sísifo
          const pedY = sy - pedH * 0.7;

          // atualiza colisões e desenha pedras
          atualizarPedrasCaindo(sx, sy, sisW, sisH);  // personagem
          atualizarPedrasCaindo(pedX, pedY, pedW, pedH); // pedra que ele carrega
        }

        if (estado === ESTADOS.QUEDA) {
          const q = pQueda;
          const px = q.x - pedW / 2;
          const py = q.y - pedH / 2;
          ctx.save(); ctx.translate(px + pedW / 2, py + pedH / 2); ctx.rotate(progressoQueda * Math.PI * 3.6); if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, -pedW / 2, -pedH / 2, pedW, pedH); ctx.restore();
        }
      }

      // placar
      if (mostrarScore) placarEl.textContent = '';
      else placarEl.textContent = `Montanhas: ${montanhas}`;

      requestAnimationFrame(loop);
    }


    // start loop
    requestAnimationFrame(loop);

    // inicializa ranking no carregamento
    atualizarRanking();

    // expose algumas funções para debug via console (opcional)
    window._game = { reiniciarParaParado, iniciarCiclo, atualizarRanking };

    // --------------------------
    // helpers / utilitários pequenos (mantém o código com mais linhas — útil para chegar perto do tamanho original)
    // --------------------------
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function safeNumber(v, fallback = 0) { const n = Number(v); return Number.isNaN(n) ? fallback : n; }

    // --------------------------
    // pequenas melhorias de usabilidade: iniciar com toque na tela (mobile)
    // --------------------------
    let tapped = false;
    function handleStartEvent() { if (!tapped) { tapped = true; /* futuro: desbloquear áudio */ } }
    window.addEventListener('touchstart', handleStartEvent, { passive: true });
  </script>
</body>

</html>
