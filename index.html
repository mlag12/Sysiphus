<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sísifo na Montanha — Versão Mobile com Slider Aprimorado</title>
    <style>
        :root {
            --btn-bg: linear-gradient(135deg, #ff004d, #ffb347);
            --btn-border: #000;
            --accent: #ff004d;
            --neon: #00ffff;
            --slider-track-bg: rgba(255, 255, 255, 0.2);
            --slider-handle-bg: #ff004d;
            --slider-handle-active-bg: #ffb347;
        }

        /* reset mínimo */
        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: #000;
            color: #fff;
            font-family: "Courier New", monospace;
            overflow: hidden; /* Evita barras de rolagem */
        }

        /* canvas full screen */
        #game {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        /* UI overlay */
        #ui {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
        }

        #placar {
            position: absolute;
            top: 2%;
            left: 2%;
            color: #fff;
            font-weight: 800;
            font-size: 3vh;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
            z-index: 110;
            white-space: nowrap;
        }

        /* Container para o Slider */
        #slider-container {
            position: fixed;
            bottom: 3%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 120;
            pointer-events: auto;
            width: 60%; /* Largura do slider diminuída para 60% */
            max-width: 400px; /* Largura máxima em telas grandes também diminuída */
            height: 60px; /* Altura da área do slider */
            background: var(--slider-track-bg);
            border-radius: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        #slider-handle {
            position: absolute;
            width: 50px; /* Tamanho do handle do slider */
            height: 50px;
            background: var(--slider-handle-bg);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        #slider-handle.active {
            background: var(--slider-handle-active-bg);
            transform: scale(1.1);
        }

        /* Menu e Ranking */
        #menu-container {
            position: fixed;
            top: 2%;
            right: 2%;
            z-index: 130;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
        }

        #botao-menu {
            cursor: pointer;
            font-size: 16px;
            background: var(--btn-bg);
            border: 2px solid #000;
            padding: 6px 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            color: #fff; /* Adicionado para garantir a cor do texto */
        }

        #menu-itens {
            display: none;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            margin-top: 4px;
        }

        #menu-container.open #menu-itens {
            display: flex;
        }

        #menu-itens button,
        #menu-itens label {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
            cursor: pointer;
            font-size: 15px;
            background: var(--btn-bg);
            border: 2px solid #000;
            padding: 8px 12px;
            border-radius: 8px;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            color: #fff; /* Adicionado para garantir a cor do texto */
        }

        #menu-itens label input {
            margin-left: 0;
            transform: scale(1.1);
        }

        /* Ranking Modal */
        #ranking-absurdo {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(2deg);
            padding: 5vh 8vw;
            background: rgba(0, 0, 0, 0.95);
            border: 4px dashed red;
            color: white;
            font-family: "Courier New", monospace;
            font-size: 3.5vh;
            text-align: center;
            z-index: 1000;
            max-height: 70vh;
            overflow-y: auto;
            min-width: 300px; /* Ajustado para melhor visualização em telas menores */
            width: auto;
            white-space: nowrap;
            box-shadow: 0 0 20px rgba(255,0,77,0.5);
        }

        #ranking-absurdo h1 {
            font-family: Impact, fantasy;
            font-size: 6vh;
            color: var(--accent);
            text-shadow: 2px 2px 6px rgba(255, 0, 77, 0.5);
            margin-bottom: 2vh;
            border-bottom: 2px dashed yellow;
            padding-bottom: 1vh;
        }

        #ranking-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #ranking-list li {
            margin-bottom: 1.2vh;
            color: var(--neon);
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 255, 255, 0.4);
        }

        /* Name Input Box */
        .caixa-nome {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-5deg);
            padding: 5vh 8vw;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: 4px dashed yellow;
            color: white;
            font-family: "Courier New", monospace;
            font-size: 4.5vh;
            text-align: center;
            z-index: 999;
            width: 80%; /* Ocupa 80% da largura */
            max-width: 400px; /* Largura máxima para não ficar muito grande */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border-radius: 10px;
        }

        .caixa-nome p {
            line-height: 1.5;
        }

        .caixa-nome input {
            font-size: 3vh;
            padding: 12px;
            width: 100%;
            border-radius: 8px;
            border: 2px solid #000;
            margin-top: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            color: #333;
        }

        .caixa-nome button {
            margin-top: 16px;
            font-size: 2.8vh;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            background: var(--btn-bg);
            border: 2px solid var(--btn-border);
            color: #fff;
            font-weight: 900;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>

    <div id="ui">
        <div id="placar">Montanhas: 0</div>

        <div id="slider-container">
            <div id="slider-handle"></div>
        </div>

        <div id="menu-container">
            <button id="botao-menu">Menu</button>
            <div id="menu-itens">
                <button id="botao-ranking">Ranking</button>
                <label><input type="checkbox" id="mostrar-score"> Mostrar Score</label>
            </div>
        </div>

        <div id="ranking-absurdo">
            <h1>TOP 10:</h1>
            <ul id="ranking-list"></ul>
        </div>
    </div>

    <script type="module">
        // --------------------------
        // Firebase v10 (Firestore)
        // --------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import {
            getFirestore,
            collection,
            addDoc,
            getDocs,
            query,
            orderBy,
            limit
        } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // === Firebase configuration - mantenha a sua informação aqui ===
        const firebaseConfig = {
            apiKey: "AIzaSyAk2SE580mZCNbLpAboxC7A4FlviilKtIE",
            authDomain: "sysiphus-afea7.firebaseapp.com",
            projectId: "sysiphus-afea7",
            storageBucket: "sysiphus-afea7.firebasestorage.app",
            messagingSenderId: "182996428651",
            appId: "1:182996428651:web:82675bca0f31c978db8e2e",
            measurementId: "G-G6N5MKSFV3"
        };

        // Inicializa o Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Referência para a coleção de scores
        const scoresCollection = collection(db, "scores");

        // --------------------------
        // Elementos DOM
        // --------------------------
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const placarEl = document.getElementById('placar');

        // Slider Elements
        const sliderContainer = document.getElementById('slider-container');
        const sliderHandle = document.getElementById('slider-handle');

        const botaoMenu = document.getElementById('botao-menu');
        const menuContainer = document.getElementById('menu-container');
        const botaoRanking = document.getElementById('botao-ranking');
        const rankingBox = document.getElementById('ranking-absurdo');
        const rankingList = document.getElementById('ranking-list');
        const checkbox = document.getElementById('mostrar-score');

        // --------------------------
        // Imagens (coloque na pasta images)
        // --------------------------
        const IMG_BG = new Image(); IMG_BG.src = 'images/montanha.jpg';
        const IMG_SISIFO = new Image(); IMG_SISIFO.src = 'images/sisifo.png';
        const IMG_PEDRA = new Image(); IMG_PEDRA.src = 'images/pedra.png';

        // --------------------------
        // Estado do jogo
        // --------------------------
        const ESTADOS = { PARADO: 0, SUBINDO: 1, PAUSA: 2, QUEDA: 3, SUICIDIO: 4 };
        let estado = ESTADOS.PARADO;
        let montanhas = 0; // Contador que NÃO zera ao final de um ciclo
        let mostrarScore = false;

        // Estado do Slider
        let isSliderDragging = false;
        let sliderRelativeX = 0.5; // Posição horizontal do slider (0 a 1)
        let characterOffsetX = 0; // Deslocamento horizontal do personagem

        checkbox.addEventListener('change', () => { mostrarScore = checkbox.checked; });
        botaoMenu.addEventListener('click', () => menuContainer.classList.toggle('open'));

        botaoRanking.addEventListener('click', () => {
            const isShown = rankingBox.style.display === 'block';
            rankingBox.style.display = isShown ? 'none' : 'block';
            if (!isShown) atualizarRanking();
        });

        // --------------------------
        // Pedras caindo durante subida
        // --------------------------
        const pedrasCaindo = [];
        const PEDRA_CAI_W = 40; // Largura padrão da pedra
        const PEDRA_CAI_H = 40; // Altura padrão da pedra
        const NUM_PEDRAS_POR_GERACAO = 5; // Máximo de 5 pedras por vez
        const VELOCIDADE_PEDRA_MIN = 5; // Velocidade mínima aumentada
        const VELOCIDADE_PEDRA_MAX = 9; // Velocidade máxima aumentada
        const FREQUENCIA_GERACAO_PEDRA = 0.03; // Chance aumentada de gerar um grupo de pedras

        // --- resize canvas & curves ---
        const curvaSubidaPct = [{ x: 0.15, y: 0.65 }, { x: 0.25, y: 0.40 }, { x: 0.40, y: 0.40 }, { x: 0.60, y: 0.40 }];
        const curvaQuedaPct = [{ x: 0.70, y: 0.40 }, { x: 0.75, y: 0.55 }, { x: 0.90, y: 0.65 }, { x: 0.99, y: 0.75 }];
        let curvaSubida, curvaQueda;

        function pctToPx(curva) { return curva.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height })); }

        function resize() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            curvaSubida = pctToPx(curvaSubidaPct); curvaQueda = pctToPx(curvaQuedaPct);
            updateSliderHandlePosition(sliderRelativeX); // Garante que o handle se ajuste após o resize
        }
        window.addEventListener('resize', resize); resize();

        // --- Controles do Slider ---
        function getTouchPosition(event) {
            const touch = event.touches ? event.touches[0] : event;
            const rect = sliderContainer.getBoundingClientRect();
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function updateSliderHandlePosition(relativeX) {
            const sliderWidth = sliderContainer.clientWidth;
            const handleWidth = sliderHandle.clientWidth;
            const minHandleX = handleWidth / 2;
            const maxHandleX = sliderWidth - handleWidth / 2;

            const handleX = minHandleX + (maxHandleX - minHandleX) * relativeX;
            sliderHandle.style.left = `${handleX - handleWidth / 2}px`;

            // Ajusta o deslocamento máximo do personagem baseado na largura do slider
            const maxCharacterOffset = sliderWidth * 0.4;
            characterOffsetX = (sliderRelativeX - 0.5) * 2 * maxCharacterOffset;
        }

        function onSliderStart(event) {
            // Permite interagir com o slider se o jogo estiver SUBINDO ou PARADO (para iniciar)
            if (estado !== ESTADOS.SUBINDO && estado !== ESTADOS.PARADO) return;

            event.preventDefault();
            isSliderDragging = true;
            sliderHandle.classList.add('active');
            
            if (estado === ESTADOS.PARADO) {
                iniciarCiclo();
            }
        }

        function onSliderMove(event) {
            // Move o slider apenas se estiver arrastando E o jogo estiver em estado de SUBIDA
            if (!isSliderDragging || estado !== ESTADOS.SUBINDO) return;
            event.preventDefault();
            const pos = getTouchPosition(event);
            const sliderWidth = sliderContainer.clientWidth;
            const handleWidth = sliderHandle.clientWidth;

            const newRelativeX = (pos.x - handleWidth / 2) / (sliderWidth - handleWidth);
            sliderRelativeX = clamp(newRelativeX, 0, 1);

            updateSliderHandlePosition(sliderRelativeX);
        }

        function onSliderEnd(event) {
            event.preventDefault();
            isSliderDragging = false;
            sliderHandle.classList.remove('active');
        }

        sliderContainer.addEventListener('touchstart', onSliderStart, { passive: false });
        sliderContainer.addEventListener('touchmove', onSliderMove, { passive: false });
        sliderContainer.addEventListener('touchend', onSliderEnd, { passive: false });
        sliderContainer.addEventListener('touchcancel', onSliderEnd, { passive: false });

        // Adiciona listeners para desktop também
        sliderContainer.addEventListener('mousedown', onSliderStart, { passive: false });
        document.addEventListener('mousemove', onSliderMove, { passive: false }); // Captura movimento fora do container
        document.addEventListener('mouseup', onSliderEnd);
        document.addEventListener('mouseleave', onSliderEnd); // Finaliza o drag se o mouse sair da janela

        // --- movimento / física ---
        function cubicBezierPoint(t, p0, p1, p2, p3) {
            const lerp = (a, b, t) => ({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });
            const a = lerp(p0, p1, t), b = lerp(p1, p2, t), c = lerp(p2, p3, t);
            const d = lerp(a, b, t), e = lerp(b, c, t);
            return lerp(d, e, t);
        }

        let progressoSubida = 0, velSubida = 0;
        let maxVelSubida = 0.01, aceleracaoSubida = 0.0005;
        let progressoQueda = 0, velQueda = 0;
        let aceleracaoQuedaInit = 0.008, gravidadeQueda = 0.0002, pausaFrames = 0;

        function iniciarCiclo() {
            estado = ESTADOS.SUBINDO;
            progressoSubida = 0;
            velSubida = 0.005; // Velocidade inicial suave
            progressoQueda = 0;
            velQueda = 0;
            pedrasCaindo.length = 0; // Limpa as pedras para um novo ciclo
            sliderRelativeX = 0.5; // Reseta o slider para o centro
            characterOffsetX = 0; // Reseta o offset horizontal do personagem
            updateSliderHandlePosition(sliderRelativeX); // Atualiza a posição visual do handle
            // Montanhas agora NÃO zera aqui
            placarEl.textContent = `Montanhas: ${montanhas}`; // Atualiza placar inicial
            console.log("Iniciando novo ciclo!");
        }

        function reiniciarParaParado() {
            montanhas++; // Incrementa montanhas sem zerar
            estado = ESTADOS.PARADO;
            progressoSubida = 0;
            progressoQueda = 0;
            velSubida = 0;
            velQueda = 0;
            pedrasCaindo.length = 0; // Limpa as pedras
            sliderRelativeX = 0.5; // Reseta slider
            characterOffsetX = 0;
            updateSliderHandlePosition(sliderRelativeX);
            placarEl.textContent = `Montanhas: ${montanhas}`; // Atualiza placar com o novo valor
            console.log(`Ciclo concluído. Montanhas: ${montanhas}`);
        }

        function gerarPedraCaindo(xPersonagem, wPersonagem) {
            // Gera um grupo de pedras
            for (let i = 0; i < NUM_PEDRAS_POR_GERACAO; i++) {
                let x;
                const zonaExclusao = canvas.width * 0.2; // Zona segura ao redor do personagem

                // Tenta gerar a pedra fora da zona de exclusão
                let attempts = 0;
                do {
                    x = Math.random() * (canvas.width - PEDRA_CAI_W);
                    attempts++;
                    if (attempts > 50) break; // Evita loop infinito se a tela for muito pequena
                } while (Math.abs(x - (xPersonagem + wPersonagem / 2)) < zonaExclusao);

                // Escala o início verticalmente para cada pedra do grupo, criando um efeito cascata
                const y = -PEDRA_CAI_H - (i * PEDRA_CAI_H * 0.4); 
                const velocidade = VELOCIDADE_PEDRA_MIN + Math.random() * (VELOCIDADE_PEDRA_MAX - VELOCIDADE_PEDRA_MIN);
                pedrasCaindo.push({ x, y, velocidade });
            }
        }

        function atualizarPedrasCaindo(xPersonagem, yPersonagem, wPersonagem, hPersonagem) {
            for (let i = pedrasCaindo.length - 1; i >= 0; i--) {
                const ped = pedrasCaindo[i];

                ped.y += ped.velocidade;

                if (IMG_PEDRA.complete) {
                    ctx.drawImage(IMG_PEDRA, ped.x, ped.y, PEDRA_CAI_W, PEDRA_CAI_H);
                }

                // Checar colisão com o personagem
                if (
                    ped.x < xPersonagem + wPersonagem &&
                    ped.x + PEDRA_CAI_W > xPersonagem &&
                    ped.y < yPersonagem + hPersonagem &&
                    ped.y + PEDRA_CAI_H > yPersonagem
                ) {
                    pedrasCaindo.splice(i, 1);
                    fimDoJogoSuicidio();
                    return; // Sai para evitar processar mais pedras neste frame após colisão
                }

                // Remove pedra se saiu da tela
                if (ped.y > canvas.height) {
                    pedrasCaindo.splice(i, 1);
                }
            }
        }

        // --------------------------
        // FIREBASE: salvar apenas se entra no top10
        // --------------------------
        async function salvarScoreSeTop10(nome, score) {
            try {
                const top10Query = query(scoresCollection, orderBy("score", "desc"), limit(10));
                const snapshot = await getDocs(top10Query);
                let top10 = [];
                snapshot.forEach(doc => {
                    top10.push({ id: doc.id, ...doc.data() });
                });

                const entrou = top10.length < 10 || score > top10[top10.length - 1].score;

                if (entrou) {
                    await addDoc(scoresCollection, {
                        name: nome || "Anônimo",
                        score: Number(score),
                        createdAt: new Date()
                    });
                }
                return entrou;
            } catch (err) {
                console.error("Erro ao salvar score:", err);
                return false;
            }
        }

        // --------------------------
        // Atualiza ranking exibido (top 10) a partir do Firestore
        // --------------------------
        async function atualizarRanking() {
            try {
                const top10Query = query(scoresCollection, orderBy("score", "desc"), limit(10));
                const snapshot = await getDocs(top10Query);

                rankingList.innerHTML = '';
                const scores = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    scores.push({ nome: data.name || 'Anônimo', score: Number(data.score) || 0 });
                });

                if (scores.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'Ainda não há scores.';
                    rankingList.appendChild(li);
                    return;
                }

                scores.forEach((s, i) => {
                    const li = document.createElement('li');
                    li.textContent = `${i + 1}. ${s.nome} - ${s.score}`;
                    rankingList.appendChild(li);
                });
            } catch (err) {
                console.error("Erro ao atualizar ranking:", err);
            }
        }

        // --------------------------
        // fim do jogo suicídio: pede nome e tenta salvar
        // --------------------------
        async function fimDoJogoSuicidio() {
            const scoreAtual = montanhas;

            estado = ESTADOS.PARADO;
            isSliderDragging = false;
            sliderHandle.classList.remove('active');
            sliderRelativeX = 0.5;
            characterOffsetX = 0;
            updateSliderHandlePosition(sliderRelativeX);

            const caixaNome = document.createElement('div');
            caixaNome.className = 'caixa-nome';
            caixaNome.innerHTML = `
                <p>Você atingiu <strong>${scoreAtual}</strong> montanhas!</p>
                <p>Insira seu nome para o ranking:</p>
                <input type="text" id="nome-jogador" placeholder="Seu nome..." />
                <div style="margin-top:16px">
                    <button id="salvar-absurdo">Salvar</button>
                    <button id="cancelar-absurdo" style="margin-left:10px;">Cancelar</button>
                </div>
            `;
            document.body.appendChild(caixaNome);

            document.getElementById('salvar-absurdo').addEventListener('click', async () => {
                const nome = document.getElementById('nome-jogador').value.trim() || 'Anônimo';
                await salvarScoreSeTop10(nome, scoreAtual);
                document.body.removeChild(caixaNome);
                // Ao salvar, resetamos tudo para uma nova partida "limpa"
                montanhas = 0;
                progressoSubida = 0;
                progressoQueda = 0;
                velSubida = 0;
                velQueda = 0;
                pedrasCaindo.length = 0;
                placarEl.textContent = `Montanhas: ${montanhas}`;
                atualizarRanking();
            });

            document.getElementById('cancelar-absurdo').addEventListener('click', () => {
                document.body.removeChild(caixaNome);
                // Ao cancelar, também resetamos tudo para uma nova partida "limpa"
                montanhas = 0;
                progressoSubida = 0;
                progressoQueda = 0;
                velSubida = 0;
                velQueda = 0;
                pedrasCaindo.length = 0;
                placarEl.textContent = `Montanhas: ${montanhas}`;
                atualizarRanking();
            });
        }

        // --------------------------
        // desenho de fundo otimizado
        // --------------------------
        function desenharFundo() {
            if (!IMG_BG.complete) return;

            const scaleX = canvas.width / IMG_BG.width;
            const scaleY = canvas.height / IMG_BG.height;
            const scale = Math.min(scaleX, scaleY); // Escala para caber a imagem inteira

            const w = IMG_BG.width * scale;
            const h = IMG_BG.height * scale;

            // Centraliza a imagem
            const offsetX = (canvas.width - w) / 2;
            const offsetY = (canvas.height - h) / 2;

            ctx.drawImage(IMG_BG, offsetX, offsetY, w, h);
        }

        // --------------------------
        // loop principal e renderização detalhada
        // --------------------------
        function loop() {
            // Lógica de estados do jogo
            if (estado === ESTADOS.SUBINDO) {
                velSubida += aceleracaoSubida;
                velSubida = clamp(velSubida, 0, maxVelSubida);

                progressoSubida += velSubida;
                progressoSubida = clamp(progressoSubida, 0, 1);

                // Transição para PAUSA ao atingir o topo
                if (progressoSubida >= 1) {
                    estado = ESTADOS.PAUSA;
                    pausaFrames = 15; // Duração da pausa antes da queda
                    progressoQueda = 0;
                    velQueda = aceleracaoQuedaInit; // Velocidade inicial da queda
                }
            } else if (estado === ESTADOS.PAUSA) {
                pausaFrames--;
                if (pausaFrames <= 0) estado = ESTADOS.QUEDA; // Inicia a queda após a pausa
            } else if (estado === ESTADOS.QUEDA) {
                velQueda += gravidadeQueda;
                progressoQueda += velQueda;
                progressoQueda = clamp(progressoQueda, 0, 1);
                // Reinicia para o próximo ciclo quando a queda termina
                if (progressoQueda >= 1) {
                    reiniciarParaParado();
                }
            } else if (estado === ESTADOS.SUICIDIO) {
                velQueda += gravidadeQueda; // Simula a gravidade durante o estado de "suicídio"
                progressoQueda += velQueda;
                progressoQueda = clamp(progressoQueda, 0, 1);
                // Chama a tela de fim de jogo quando a queda termina
                if (progressoQueda >= 1) {
                    estado = ESTADOS.PARADO;
                    fimDoJogoSuicidio();
                }
            }

            // Limpa o canvas e desenha o fundo
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            desenharFundo();

            // Calcula posições baseadas nas curvas Bezier
            const pSisBase = cubicBezierPoint(progressoSubida, ...curvaSubida);
            const pQueda = cubicBezierPoint(progressoQueda, ...curvaQueda);

            // Dimensões relativas para Sísifo e a pedra
            const sisW = canvas.width * 0.12; const sisH = sisW * (IMG_SISIFO.height / IMG_SISIFO.width || 1);
            const pedW = sisW * 0.7; const pedH = pedW;

            // Desenho condicional baseado no estado do jogo
            if (estado === ESTADOS.SUICIDIO) {
                const q = pQueda;
                // Efeitos visuais para a queda e colisão
                const sisDesvio = Math.sin(progressoQueda * Math.PI * 0.5) * (canvas.width * 0.04);
                const sx = q.x - sisW / 2 + sisDesvio; const sy = q.y - sisH / 2;
                if (IMG_SISIFO.complete) ctx.drawImage(IMG_SISIFO, sx, sy, sisW, sisH);

                const px = q.x - pedW / 2 + Math.cos(progressoQueda * Math.PI * 1.5) * (canvas.width * 0.035);
                const py = q.y - pedH / 2;
                ctx.save(); ctx.translate(px + pedW / 2, py + pedH / 2); ctx.rotate(progressoQueda * Math.PI * 1.5); if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, -pedW / 2, -pedH / 2, pedW, pedH); ctx.restore();

            } else {
                // Desenha Sísifo na posição base + offset horizontal do slider
                const s = pSisBase;
                const sx = s.x - sisW / 2 + characterOffsetX;
                const sy = s.y - sisH + (canvas.height * 0.01);
                if (IMG_SISIFO.complete) ctx.drawImage(IMG_SISIFO, sx, sy, sisW, sisH);

                // Desenha a pedra que Sísifo está carregando
                if (estado === ESTADOS.SUBINDO || estado === ESTADOS.PAUSA) {
                    const pedX = sx + sisW * 0.4;
                    const pedY = sy - pedH * 0.7;
                    if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, pedX, pedY, pedW, pedH);
                }

                // Lógica de geração e atualização das pedras que caem
                if (estado === ESTADOS.SUBINDO) {
                    // Gera novas pedras com uma certa frequência
                    if (Math.random() < FREQUENCIA_GERACAO_PEDRA) {
                        gerarPedraCaindo(sx, sisW);
                    }
                    // Atualiza posição e verifica colisões das pedras que já estão caindo
                    atualizarPedrasCaindo(sx, sy, sisW, sisH);
                }

                // Desenha a pedra caindo livremente durante o estado de queda normal
                if (estado === ESTADOS.QUEDA) {
                    const q = pQueda;
                    const px = q.x - pedW / 2; const py = q.y - pedH / 2;
                    ctx.save(); ctx.translate(px + pedW / 2, py + pedH / 2); ctx.rotate(progressoQueda * Math.PI * 3.6); if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, -pedW / 2, -pedH / 2, pedW, pedH); ctx.restore();
                }
            }

            // Atualiza o placar na tela
            if (mostrarScore) placarEl.textContent = '';
            else placarEl.textContent = `Montanhas: ${montanhas}`;

            requestAnimationFrame(loop); // Continua o loop de animação
        }

        // Inicia o loop principal do jogo
        requestAnimationFrame(loop);

        // Atualiza o ranking na tela ao carregar
        atualizarRanking();

        // Exibe funções úteis no console para debug (opcional)
        window._game = { reiniciarParaParado, iniciarCiclo, atualizarRanking };

        // --------------------------
        // helpers / utilitários pequenos
        // --------------------------
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        function safeNumber(v, fallback = 0) { const n = Number(v); return Number.isNaN(n) ? fallback : n; }

        // --------------------------
        // pequenos melhorias de usabilidade: iniciar com toque na tela (mobile)
        // --------------------------
        let tapped = false;
        function handleStartEvent() {
            if (!tapped) {
                tapped = true;
                // Aqui pode-se adicionar lógicas para iniciar áudio, etc.
            }
            // Inicia o ciclo do jogo se ele estiver parado e houver qualquer interação
            if (estado === ESTADOS.PARADO) {
                 iniciarCiclo();
            }
        }
        // Adiciona listener a todo o corpo para qualquer toque/clique iniciar o jogo
        window.addEventListener('touchstart', handleStartEvent, { passive: true });
        window.addEventListener('mousedown', handleStartEvent, { passive: true }); // Para desktop

    </script>
</body>
</html>
