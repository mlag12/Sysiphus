<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sísifo na Montanha — Versão Responsiva</title>
  <style>
    :root {
      --btn-bg: linear-gradient(135deg, #ff004d, #ffb347);
      --btn-border: #000;
      --accent: #ff004d;
      --neon: #00ffff;
    }

    /* reset mínimo */
    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #000;
      color: #fff;
      font-family: "Courier New", monospace;
      overflow: hidden;
      /* Evita barras de rolagem */
    }

    /* canvas full screen */
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #000;
    }

    /* UI overlay */
    #ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 100;
    }

    #placar {
      position: absolute;
      top: 2%;
      left: 2%;
      color: #fff;
      font-weight: 800;
      font-size: 3vh;
      text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
      z-index: 110;
      white-space: nowrap;
    }

    /* --- Joystick Estilizado (Barra Horizontal) --- */
    #joystick-container {
      position: fixed;
      bottom: 3%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 120;
      pointer-events: auto;
      display: flex;
      justify-content: center; /* Centraliza o conteúdo horizontalmente */
      align-items: center;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px; /* Bordas mais retas para a barra */
      padding: 15px 30px; /* Padding horizontal maior */
      border: 3px dashed var(--neon);
      width: 300px; /* Largura da barra do joystick */
      height: 80px; /* Altura da barra do joystick */
    }

    #joystick-base {
      width: 100%;
      height: 20px; /* Altura da "trilha" */
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      position: relative;
      display: flex; /* Para centralizar o thumb na altura */
      align-items: center;
      cursor: grab;
    }

    #joystick-thumb {
      width: 50px; /* Tamanho ligeiramente menor para mais responsividade */
      height: 50px; /* Tamanho ligeiramente menor para mais responsividade */
      background: var(--btn-bg);
      border: 4px solid var(--btn-border);
      border-radius: 50%;
      position: absolute;
      cursor: grab;
      transition: none; /* Remove transição para controle mais responsivo */
      box-shadow: 0 0 15px rgba(255, 0, 77, 0.7);
      transform: translateX(-50%); /* Ajuste para o centro do thumb */
      left: 50%; /* Posição inicial central */
    }

    /* --- Fim do Joystick Estilizado --- */


    #menu-container {
      position: fixed;
      top: 2%;
      right: 2%;
      z-index: 130;
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }

    #botao-menu {
      cursor: pointer;
      font-size: 16px;
      background: var(--btn-bg);
      border: 2px solid #000;
      padding: 6px 10px;
      border-radius: 8px;
    }

    #menu-itens {
      display: none;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      margin-top: 4px;
    }

    #menu-container.open #menu-itens {
      display: flex;
    }

    #menu-itens button,
    #menu-itens label {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      cursor: pointer;
      font-size: 15px;
      background: var(--btn-bg);
      border: 2px solid #000;
      padding: 8px 12px;
      border-radius: 8px;
      white-space: nowrap;
    }

    #menu-itens label input {
      margin-left: 0;
      transform: scale(1.1);
    }

    /* ranking modal */
    #ranking-absurdo {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(2deg);
      padding: 5vh 8vw;
      background: rgba(0, 0, 0, 0.95);
      border: 4px dashed red;
      color: white;
      font-family: "Courier New", monospace;
      font-size: 3.5vh;
      text-align: center;
      z-index: 1000;
      max-height: 70vh;
      overflow-y: auto;
      min-width: 400px;
      width: auto;
      white-space: nowrap;
    }


    #ranking-absurdo h1 {
      font-family: Impact, fantasy;
      font-size: 6vh;
      color: var(--accent);
      text-shadow: 2px 2px 6px rgba(255, 0, 77, 0.5);
      margin-bottom: 2vh;
      border-bottom: 2px dashed yellow;
      padding-bottom: 1vh;
    }

    #ranking-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #ranking-list li {
      margin-bottom: 1.2vh;
      color: var(--neon);
      font-weight: bold;
      text-shadow: 1px 1px 3px rgba(0, 255, 255, 0.4);
    }

    /* name input box */
    .caixa-nome {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-5deg);
      padding: 5vh 8vw;
      background: linear-gradient(45deg, #ff00ff, #00ffff);
      border: 4px dashed yellow;
      color: white;
      font-family: "Courier New", monospace;
      font-size: 4.5vh;
      text-align: center;
      z-index: 999;
    }

    .caixa-nome p {
      line-height: 1.5;
    }

    .caixa-nome input {
      font-size: 3vh;
      padding: 12px;
      width: 100%;
      border-radius: 8px;
      border: 2px solid #000;
      margin-top: 10px;
    }

    .caixa-nome button {
      margin-top: 16px;
      font-size: 2.8vh;
      padding: 10px 20px;
      border-radius: 10px;
      cursor: pointer;
    }

    /* Oculta o botão antigo de empurrar */
    #botao-empurrar {
      display: none;
    }
  </style>
</head>

<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div id="placar">Montanhas: 0</div>

    <div id="joystick-container">
      <div id="joystick-base">
        <div id="joystick-thumb"></div>
      </div>
    </div>
    <div id="menu-container">
      <button id="botao-menu">Menu</button>
      <div id="menu-itens">
        <button id="botao-ranking">Ranking</button>
        <label><input type="checkbox" id="mostrar-score"> Mostrar Score</label>
      </div>
    </div>

    <div id="ranking-absurdo">
      <h1>TOP 10:</h1>
      <ul id="ranking-list"></ul>
    </div>
  </div>

  <script type="module">
    // --------------------------
    // Firebase v10 (Firestore)
    // --------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore,
      collection,
      addDoc,
      getDocs,
      query,
      orderBy,
      limit
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    // === Firebase configuration - mantenha a sua informação aqui ===
    const firebaseConfig = {
      apiKey: "AIzaSyAk2SE580mZCNbLpAboxC7A4FlviilKtIE",
      authDomain: "sysiphus-afea7.firebaseapp.com",
      projectId: "sysiphus-afea7",
      storageBucket: "sysiphus-afea7.firebasestorage.app",
      messagingSenderId: "182996428651",
      appId: "1:182996428651:web:82675bca0f31c978db8e2e",
      measurementId: "G-G6N5MKSFV3"
    };

    // Inicializa o Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Referência para a coleção de scores
    const scoresCollection = collection(db, "scores");

    // --------------------------
    // Elementos DOM
    // --------------------------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const placarEl = document.getElementById('placar');

    // Joystick Elements
    const joystickContainer = document.getElementById('joystick-container');
    const joystickThumb = document.getElementById('joystick-thumb');
    const joystickBase = document.getElementById('joystick-base');

    const botaoMenu = document.getElementById('botao-menu');
    const menuContainer = document.getElementById('menu-container');
    const botaoRanking = document.getElementById('botao-ranking');
    const rankingBox = document.getElementById('ranking-absurdo');
    const rankingList = document.getElementById('ranking-list');
    const checkbox = document.getElementById('mostrar-score');

    // --------------------------
    // Imagens (coloque na pasta images)
    // --------------------------
    const IMG_BG = new Image(); IMG_BG.src = 'images/montanha.jpg';
    const IMG_SISIFO = new Image(); IMG_SISIFO.src = 'images/sisifo.png';
    const IMG_PEDRA = new Image(); IMG_PEDRA.src = 'images/pedra.png';

    // --------------------------
    // Estado do jogo
    // --------------------------
    const ESTADOS = { PARADO: 0, SUBINDO: 1, PAUSA: 2, QUEDA: 3, SUICIDIO: 4 };
    let estado = ESTADOS.PARADO;
    let montanhas = 0;
    let movimentoAtivo = false; // Indica se há input válido do joystick
    let mostrarScore = false;

    // Variáveis para controle horizontal do personagem
    let movimentoHorizontal = 0; // Valor entre -1 (esquerda) e 1 (direita)
    let personagemOffsetX = 0; // Deslocamento horizontal do personagem em pixels
    const maxPersonagemOffsetX = 0.15 * canvas.width; // Desvio máximo horizontal (15% da tela) - reduzido para focar mais na subida
    const sensibilidadePersonagem = 0.01; // Aumentada para mais responsividade

    checkbox.addEventListener('change', () => { mostrarScore = checkbox.checked; });
    botaoMenu.addEventListener('click', () => menuContainer.classList.toggle('open'));

    botaoRanking.addEventListener('click', () => {
      const isShown = rankingBox.style.display === 'block';
      rankingBox.style.display = isShown ? 'none' : 'block';
      if (!isShown) atualizarRanking();
    });

    // --------------------------
    // novas pedras caindo durante subida
    // --------------------------
    const pedrasCaindo = [];
    const PEDRA_CAI_W = 40; // largura padrão
    const PEDRA_CAI_H = 40; // altura padrão
    const freqQueda = 0.01; // chance de gerar pedra a cada frame (0-1)


    // --- resize canvas & curves ---
    const curvaSubidaPct = [{ x: 0.15, y: 0.65 }, { x: 0.25, y: 0.40 }, { x: 0.40, y: 0.40 }, { x: 0.60, y: 0.40 }];
    const curvaQuedaPct = [{ x: 0.70, y: 0.40 }, { x: 0.75, y: 0.55 }, { x: 0.90, y: 0.65 }, { x: 0.99, y: 0.75 }];
    let curvaSubidaBasePx, curvaQueda; // Estas serão as curvas em pixel.

    function pctToPx(curva) { return curva.map(p => ({ x: p.x * canvas.width, y: p.y * canvas.height })); }

    function resize() {
      canvas.width = window.innerWidth; canvas.height = window.innerHeight;
      curvaSubidaBasePx = pctToPx(curvaSubidaPct); // Usa a curva base para conversão inicial
      curvaQueda = pctToPx(curvaQuedaPct);
    }
    window.addEventListener('resize', resize); resize();

    // --- Joystick Logic ---
    let joystickThumbCenterX = 0; // Posição X relativa do centro do thumb dentro da base
    let isDragging = false;

    function updateJoystickPosition(clientX) {
      const rectBase = joystickBase.getBoundingClientRect();
      const thumbWidth = joystickThumb.offsetWidth; // Pega a largura do thumb

      // Calcula a posição do mouse/toque relativa ao *centro da base* do joystick
      let deltaX = clientX - rectBase.left - rectBase.width / 2;

      // Limita o movimento do centro do thumb para que ele não saia da base
      const maxDeltaX = (rectBase.width - thumbWidth) / 2;
      deltaX = clamp(deltaX, -maxDeltaX, maxDeltaX);

      joystickThumbCenterX = deltaX; // Atualiza a posição X relativa do thumb

      // Aplica a posição ao thumb do joystick.
      joystickThumb.style.left = `calc(50% + ${joystickThumbCenterX}px)`;

      // Normaliza o movimento horizontal para um valor entre -1 e 1
      const normalizedMovement = joystickThumbCenterX / maxDeltaX;

      // Determina o movimento horizontal com base na posição e na dead zone
      const deadZoneFactor = 0.2; // 20% de dead zone (para a esquerda e para a direita)
      if (Math.abs(normalizedMovement) > deadZoneFactor) {
        movimentoHorizontal = Math.sign(normalizedMovement) *
                              ((Math.abs(normalizedMovement) - deadZoneFactor) / (1 - deadZoneFactor));
        movimentoAtivo = true;
      } else {
        movimentoHorizontal = 0; // Dentro da dead zone, para o movimento
        movimentoAtivo = false;
      }

      // Se o jogo está parado e o joystick se move para a direita (iniciar), ou para a esquerda (voltar/reiniciar)
      if (estado === ESTADOS.PARADO && movimentoHorizontal !== 0) {
        // Se movimentoHorizontal > 0 (direita), inicia o ciclo
        if (movimentoHorizontal > 0) {
            iniciarCiclo();
        } else if (movimentoHorizontal < 0) {
            // Se movimentoHorizontal < 0 (esquerda), pode ser para reiniciar ou "voltar"
            // Para este exemplo, vamos considerar que ele reinicia ou entra em estado de queda/fim.
            // Se precisar de uma mecânica específica de "voltar", ela precisa ser definida.
            // Por enquanto, vamos apenas fazer o personagem cair se arrastar para a esquerda no estado PARADO.
            estado = ESTADOS.SUICIDIO; // Simula uma queda imediata.
            progressoQueda = 0;
            velQueda = aceleracaoQuedaInit;
            personagemOffsetX = -maxPersonagemOffsetX * 0.5; // Começa um pouco para a esquerda
        }
      }
    }

    function onPointerDown(e) {
      e.preventDefault();
      isDragging = true;
      joystickThumb.style.cursor = 'grabbing';
      document.body.style.cursor = 'grabbing';
      updateJoystickPosition(e.clientX);
    }

    function onPointerMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      updateJoystickPosition(e.clientX);
    }

    function onPointerUp(e) {
      if (!isDragging) return;
      e.preventDefault();
      isDragging = false;
      joystickThumb.style.cursor = 'grab';
      document.body.style.cursor = 'default';

      // Retorna o joystick ao centro quando solto
      joystickThumb.style.left = '50%'; // Volta para a posição inicial via CSS
      joystickThumbCenterX = 0;
      // Só zera o movimentoHorizontal se o jogador não estiver mantendo um comando
      // (ex: se o estado não for mais PARADO e houver um movimento ativo)
      if (!movimentoAtivo) {
          movimentoHorizontal = 0;
      }
    }

    // Event listeners para o joystick
    joystickContainer.addEventListener('pointerdown', onPointerDown);
    joystickBase.addEventListener('pointerdown', onPointerDown); // Permite arrastar da base também
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('pointerleave', onPointerUp);

    // --- Fim do Joystick Logic ---


    // --- physics ---
    function cubicBezierPoint(t, p0, p1, p2, p3) {
      const lerp = (a, b, t) => ({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });
      const a = lerp(p0, p1, t), b = lerp(p1, p2, t), c = lerp(p2, p3, t);
      const d = lerp(a, b, t), e = lerp(b, c, t);
      return lerp(d, e, t);
    }

    let progressoSubida = 0, velSubida = 0, progressoQueda = 0, velQueda = 0;
    let maxVelSubida = 0.015, // Aumentada para subida mais rápida
        aceleracaoSubida = 0.004, // Aumentada levemente
        desaceleraSubida = 0.9;
    let aceleracaoQuedaInit = 0.01, // Aumentada
        gravidadeQueda = 0.0003, // Aumentada
        pausaFrames = 0;

    function iniciarCiclo() {
      estado = ESTADOS.SUBINDO;
      progressoSubida = 0;
      velSubida = 0.005; // Velocidade inicial ao começar
      progressoQueda = 0;
      velQueda = 0;
      personagemOffsetX = 0; // Reseta o offset ao iniciar um novo ciclo
      montanhas = 0; // Reseta as montanhas ao iniciar um novo ciclo para testar
      placarEl.textContent = `Montanhas: ${montanhas}`; // Atualiza placar
    }

    function reiniciarParaParado() {
      montanhas++;
      estado = ESTADOS.PARADO;
      progressoSubida = progressoQueda = 0;
      velSubida = velQueda = 0;
      movimentoAtivo = false;
      movimentoHorizontal = 0; // Zera o movimento horizontal
      personagemOffsetX = 0; // Zera o offset horizontal
      placarEl.textContent = `Montanhas: ${montanhas}`; // Atualiza placar
    }


    function gerarPedraCaindo(xPersonagem, yPersonagem, wPersonagem, hPersonagem) {
      let x, y = -PEDRA_CAI_H;
      const zonaExclusaoRaio = Math.max(wPersonagem, hPersonagem) * 2.5; // Aumenta zona de exclusão

      let tentativas = 0;
      do {
        x = Math.random() * (canvas.width - PEDRA_CAI_W); // posição aleatória no topo
        y = -PEDRA_CAI_H; // sempre acima do topo da tela
        tentativas++;
        if (tentativas > 100) break; // evita loop infinito caso zona cubra muito
      } while (
        Math.hypot(
          x + PEDRA_CAI_W / 2 - (xPersonagem + wPersonagem / 2),
          y + PEDRA_CAI_H / 2 - (yPersonagem + hPersonagem / 2)
        ) < zonaExclusaoRaio
      );

      const velocidade = 3 + Math.random() * 4; // Pedra cai mais rápido
      pedrasCaindo.push({ x, y, velocidade });
    }


    function atualizarPedrasCaindo(xPersonagem, yPersonagem, wPersonagem, hPersonagem) {
      for (let i = pedrasCaindo.length - 1; i >= 0; i--) {
        const ped = pedrasCaindo[i];

        // Atualiza posição da pedra
        ped.y += ped.velocidade;

        // Desenhar pedra
        if (IMG_PEDRA.complete) {
          ctx.drawImage(IMG_PEDRA, ped.x, ped.y, PEDRA_CAI_W, PEDRA_CAI_H);
        }

        // Checar colisão com o personagem
        if (
          ped.x < xPersonagem + wPersonagem &&
          ped.x + PEDRA_CAI_W > xPersonagem &&
          ped.y < yPersonagem + hPersonagem &&
          ped.y + PEDRA_CAI_H > yPersonagem
        ) {
          // Colisão detectada: remove pedra e reinicia jogo
          pedrasCaindo.splice(i, 1);

          // Fim de jogo: chama função existente
          fimDoJogoSuicidio();

          // Reseta score e progresso
          montanhas = 0;
          progressoSubida = progressoQueda = 0;
          velSubida = velQueda = 0;

          return; // sai da função para não processar mais pedras neste frame
        }

        // Remove pedra se saiu da tela
        if (ped.y > canvas.height) {
          pedrasCaindo.splice(i, 1);
        }
      }
    }



    // --------------------------
    // FIREBASE: salvar apenas se entra no top10
    // Observações importantes sobre esta função:
    // - usamos `limitToLast(10)` para trazer até 10 registros ordenados por `score`.
    // - convertendo `score` para Number para evitar problemas com strings.
    // - ao salvar, adicionamos `ts` (timestamp) e `idClient` para ajudar a depuração.
    // - validamos o `nome` (máx 20 caracteres) e o `score` (Number >=0).
    // --------------------------
    // --------------------------
    // Função para salvar score no Firestore se estiver no top 10
    // --------------------------
    async function salvarScoreSeTop10(nome, score) {
      try {
        const top10Query = query(scoresCollection, orderBy("score", "desc"), limit(10));
        const snapshot = await getDocs(top10Query);
        let top10 = [];
        snapshot.forEach(doc => {
          top10.push({ id: doc.id, ...doc.data() });
        });

        // Verifica se entrou no top 10
        const entrou = top10.length < 10 || score > top10[top10.length - 1].score;

        if (entrou) {
          // Salva o novo score
          await addDoc(scoresCollection, {
            name: nome || "Anônimo",
            score: Number(score),
            createdAt: new Date()
          });
        }

        return entrou;
      } catch (err) {
        console.error("Erro ao salvar score:", err);
        return false;
      }
    }

    // --------------------------
    // Atualiza ranking exibido (top 10) a partir do Firestore
    // --------------------------
    async function atualizarRanking() {
      try {
        const top10Query = query(scoresCollection, orderBy("score", "desc"), limit(10));
        const snapshot = await getDocs(top10Query);

        rankingList.innerHTML = '';
        const scores = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          scores.push({ nome: data.name || 'Anônimo', score: Number(data.score) || 0 });
        });

        if (scores.length === 0) {
          const li = document.createElement('li');
          li.textContent = 'Ainda não há scores.';
          rankingList.appendChild(li);
          return;
        }

        scores.forEach((s, i) => {
          const li = document.createElement('li');
          li.textContent = `${i + 1}. ${s.nome} - ${s.score}`;
          rankingList.appendChild(li);
        });
      } catch (err) {
        console.error("Erro ao atualizar ranking:", err);
      }
    }

    // --------------------------
    // fim do jogo suicídio: pede nome e tenta salvar
    // - esta função cria a caixa de input e controla estados do botão
    // - bloqueia o botão salvar durante a operação para evitar múltiplos pushes
    // --------------------------
    // Função de fim de jogo com input de nome
    async function fimDoJogoSuicidio() {
      const scoreAtual = montanhas;

      // Pausa o jogo
      estado = ESTADOS.PARADO;
      movimentoAtivo = false;
      movimentoHorizontal = 0; // Zera o movimento horizontal
      personagemOffsetX = 0; // Zera o offset horizontal

      // Cria a caixa de input
      const caixaNome = document.createElement('div');
      caixaNome.className = 'caixa-nome';
      caixaNome.innerHTML = `
        <p>Você atingiu <strong>${scoreAtual}</strong> montanhas!</p>
        <p>Insira seu nome para o ranking:</p>
        <input type="text" id="nome-jogador" placeholder="Seu nome..." />
        <div style="margin-top:16px">
            <button id="salvar-absurdo">Salvar</button>
            <button id="cancelar-absurdo" style="margin-left:10px;">Cancelar</button>
        </div>
      `;
      document.body.appendChild(caixaNome);

      // Botão Salvar
      document.getElementById('salvar-absurdo').addEventListener('click', async () => {
        const nome = document.getElementById('nome-jogador').value.trim() || 'Anônimo';
        const entrou = await salvarScoreSeTop10(nome, scoreAtual);

        if (entrou) {
          console.log('Parabéns — você entrou no TOP 10!');
        } else {
          console.log('Não entrou no TOP 10 — mas score será registrado.');
        }

        // Remove a caixa e reseta o jogo
        document.body.removeChild(caixaNome);
        montanhas = 0;
        progressoSubida = progressoQueda = 0;
        velSubida = velQueda = 0;
        placarEl.textContent = `Montanhas: ${montanhas}`;

        atualizarRanking();
      });

      // Botão Cancelar
      document.getElementById('cancelar-absurdo').addEventListener('click', () => {
        document.body.removeChild(caixaNome);

        // Reseta o jogo mesmo cancelando
        montanhas = 0;
        progressoSubida = progressoQueda = 0;
        velSubida = velQueda = 0;
        placarEl.textContent = `Montanhas: ${montanhas}`;

        atualizarRanking();
      });
    }



    // --------------------------
    // desenho de fundo otimizado
    // --------------------------
    function desenharFundo() {
      if (!IMG_BG.complete) return;

      // calcula a escala para caber toda a imagem na tela sem cortar (fit)
      const scaleX = canvas.width / IMG_BG.width;
      const scaleY = canvas.height / IMG_BG.height;
      const scale = Math.min(scaleX, scaleY); // fit: menor escala para caber tudo

      const w = IMG_BG.width * scale;
      const h = IMG_BG.height * scale;

      // centraliza a imagem
      const offsetX = (canvas.width - w) / 2;
      const offsetY = (canvas.height - h) / 2;

      ctx.drawImage(IMG_BG, offsetX, offsetY, w, h);
    }


    // --------------------------
    // loop principal e renderização detalhada
    // --------------------------
    function loop() {

      // Lógica de Estados
      if (estado === ESTADOS.SUBINDO) {
        // A velocidade de subida agora é mais constante e um pouco mais rápida
        velSubida = maxVelSubida; // Mantém a velocidade máxima
        progressoSubida += velSubida;

        // Atualiza o deslocamento horizontal do personagem com base no movimentoHorizontal
        personagemOffsetX += movimentoHorizontal * sensibilidadePersonagem * canvas.width;
        personagemOffsetX = clamp(personagemOffsetX, -maxPersonagemOffsetX, maxPersonagemOffsetX);

        if (progressoSubida >= 1) {
          progressoSubida = 1;
          estado = ESTADOS.PAUSA;
          pausaFrames = 10; // Diminui a pausa para transição mais rápida
          progressoQueda = 0;
          velQueda = aceleracaoQuedaInit;
        }
      } else if (estado === ESTADOS.PAUSA) {
        pausaFrames--;
        if (pausaFrames <= 0) estado = ESTADOS.QUEDA;
      } else if (estado === ESTADOS.QUEDA) {
        velQueda += gravidadeQueda;
        progressoQueda += velQueda;
        if (progressoQueda >= 1) {
          reiniciarParaParado();
        }
      } else if (estado === ESTADOS.SUICIDIO) {
        velQueda += gravidadeQueda;
        progressoQueda += velQueda;
        if (progressoQueda >= 1) {
          estado = ESTADOS.PARADO;
          fimDoJogoSuicidio();
        }
      }

      // Limpa e desenha fundo
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      desenharFundo();

      // Calcula posições via bezier
      const pSisBase = cubicBezierPoint(progressoSubida, ...curvaSubidaBasePx); // Ponto na curva original (para Y)
      const pQueda = cubicBezierPoint(progressoQueda, ...curvaQueda);

      // Dimensões relativas
      const sisW = canvas.width * 0.12;
      const sisH = sisW * (IMG_SISIFO.height / IMG_SISIFO.width || 1);
      const pedW = sisW * 0.7;
      const pedH = pedW;

      // --- Desenho do Sísifo com Desvio Horizontal ---
      if (estado === ESTADOS.SUICIDIO) {
        const q = pQueda;
        // Ajuste na animação de queda para ser mais dinâmica
        const sisDesvioQueda = Math.sin(progressoQueda * Math.PI * 1.5) * (canvas.width * 0.08);
        const sx = q.x - sisW / 2 + sisDesvioQueda;
        const sy = q.y - sisH / 2;
        if (IMG_SISIFO.complete) ctx.drawImage(IMG_SISIFO, sx, sy, sisW, sisH);

        const px = q.x - pedW / 2 + Math.cos(progressoQueda * Math.PI * 2.0) * (canvas.width * 0.05);
        const py = q.y - pedH / 2;
        ctx.save(); ctx.translate(px + pedW / 2, py + pedH / 2); ctx.rotate(progressoQueda * Math.PI * 2.0); if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, -pedW / 2, -pedH / 2, pedW, pedH); ctx.restore();

      } else {
        // Subida/Pausa/Queda regular
        let sx = pSisBase.x - sisW / 2 + personagemOffsetX; // Posição X baseada na curva + desvio do jogador
        const sy = pSisBase.y - sisH + (canvas.height * 0.01); // Posição Y da curva base

        // Garante que Sísifo não saia da tela
        sx = Math.max(0, Math.min(canvas.width - sisW, sx));

        if (IMG_SISIFO.complete) ctx.drawImage(IMG_SISIFO, sx, sy, sisW, sisH);

        // Desenha a pedra que Sísifo carrega (apenas em SUBINDO e PAUSA)
        if (estado === ESTADOS.SUBINDO || estado === ESTADOS.PAUSA) {
          const px = sx + sisW * 0.4; // Posição da pedra relativa a Sísifo
          const py = sy - pedH * 0.7; // Posiciona a pedra um pouco acima de Sísifo
          if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, px, py, pedW, pedH);
        }

        // Lógica para pedras caindo e colisões (apenas em SUBINDO)
        if (estado === ESTADOS.SUBINDO) {
          // Gera novas pedras com uma frequência menor, mas com maior chance de queda
          if (Math.random() < freqQueda * 1.5) { // Aumenta ligeiramente a chance de gerar
            const pedX = sx + sisW * 0.4; // Posição X da pedra baseada na posição atual de Sísifo
            gerarPedraCaindo(pedX, sy, pedW, pedH);
          }

          const pedX = sx + sisW * 0.4; // Posição X da pedra baseada na posição atual de Sísifo
          const pedY = sy - pedH * 0.7;

          // Atualiza colisões e desenha pedras caindo
          atualizarPedrasCaindo(sx, sy, sisW, sisH);   // Colisão com o personagem
          atualizarPedrasCaindo(pedX, pedY, pedW, pedH); // Colisão com a pedra que ele carrega
        }

        // Desenha a pedra caindo (apenas em QUEDA)
        if (estado === ESTADOS.QUEDA) {
          const q = pQueda;
          const px = q.x - pedW / 2;
          const py = q.y - pedH / 2;
          ctx.save(); ctx.translate(px + pedW / 2, py + pedH / 2); ctx.rotate(progressoQueda * Math.PI * 3.6); if (IMG_PEDRA.complete) ctx.drawImage(IMG_PEDRA, -pedW / 2, -pedH / 2, pedW, pedH); ctx.restore();
        }
      }

      // Placar
      if (mostrarScore) placarEl.textContent = '';
      else placarEl.textContent = `Montanhas: ${montanhas}`;

      requestAnimationFrame(loop);
    }


    // Start loop
    requestAnimationFrame(loop);

    // Inicializa ranking no carregamento
    atualizarRanking();

    // Expor algumas funções para debug via console (opcional)
    window._game = { reiniciarParaParado, iniciarCiclo, atualizarRanking };

    // --------------------------
    // Helpers / Utilitários pequenos
    // --------------------------
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function safeNumber(v, fallback = 0) { const n = Number(v); return Number.isNaN(n) ? fallback : n; }

    // --------------------------
    // Pequenas melhorias de usabilidade: iniciar com toque na tela (mobile)
    // --------------------------
    let tapped = false;
    function handleStartEvent() { if (!tapped) { tapped = true; /* futuro: desbloquear áudio */ } }
    window.addEventListener('touchstart', handleStartEvent, { passive: true });
  </script>
</body>

</html>
